name: Install 3. AWS Axialy UI Deployment

on:
  workflow_dispatch:
    inputs:
      instance_identifier:
        description: "EC2 instance identifier"
        required: true
        default: "axialy-ui"
      aws_region:
        description: "AWS region (e.g. us-west-2, us-east-1)"
        default: "us-west-2"
        required: true
      instance_type:
        description: "EC2 instance type"
        default: "t3.small"
        required: true
      domain_name:
        description: "Optional domain name for UI interface"
        required: false
        default: ""

env:
  AWS_DEFAULT_REGION: ${{ github.event.inputs.aws_region }}
  INSTANCE_IDENTIFIER: ${{ github.event.inputs.instance_identifier }}

jobs:
  prepare:
    runs-on: ubuntu-latest
    name: Prepare AWS Environment
    outputs:
      cleanup_needed: ${{ steps.check_resources.outputs.cleanup_needed }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ github.event.inputs.aws_region }}

    - name: Check for existing resources
      id: check_resources
      run: |
        echo "Checking for existing EC2 instance..."
        EXISTING_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.INSTANCE_IDENTIFIER }}" "Name=instance-state-name,Values=running,pending,stopping,stopped" \
          --query 'Reservations[].Instances[].InstanceId' --output text || echo "")
        
        if [ -n "$EXISTING_INSTANCES" ]; then
          echo "cleanup_needed=true" >> $GITHUB_OUTPUT
          echo "Existing instances found - cleanup will be performed"
        else
          echo "cleanup_needed=false" >> $GITHUB_OUTPUT
          echo "No existing instances found - proceeding with fresh deployment"
        fi

    - name: Cleanup existing resources
      if: steps.check_resources.outputs.cleanup_needed == 'true'
      run: |
        echo "Cleaning up existing EC2 instances..."
        EXISTING_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.INSTANCE_IDENTIFIER }}" "Name=instance-state-name,Values=running,pending,stopping,stopped" \
          --query 'Reservations[].Instances[].InstanceId' --output text)
        
        if [ -n "$EXISTING_INSTANCES" ]; then
          echo "Terminating instances: $EXISTING_INSTANCES"
          aws ec2 terminate-instances --instance-ids $EXISTING_INSTANCES || true
          aws ec2 wait instance-terminated --instance-ids $EXISTING_INSTANCES || true
        fi
        
        echo "Cleanup completed"

    - name: Force cleanup all related resources
      run: |
        echo "Performing comprehensive cleanup of all related resources..."
        
        # Cleanup security groups
        SG_NAME="${{ env.INSTANCE_IDENTIFIER }}-sg"
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$SG_NAME" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        if [ "$SG_ID" != "None" ] && [ "$SG_ID" != "" ]; then
          echo "Deleting security group $SG_ID..."
          aws ec2 delete-security-group --group-id "$SG_ID" || true
        fi
        
        # Cleanup CloudWatch log groups
        LOG_GROUP="/aws/ec2/${{ env.INSTANCE_IDENTIFIER }}"
        if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text 2>/dev/null | grep -q "$LOG_GROUP"; then
          echo "Deleting log group $LOG_GROUP..."
          aws logs delete-log-group --log-group-name "$LOG_GROUP" || true
        fi
        
        echo "✓ Comprehensive cleanup completed"

  deploy:
    runs-on: ubuntu-latest
    name: Deploy EC2 and Configure UI Application
    needs: prepare
    outputs:
      instance_id: ${{ steps.deploy_ec2.outputs.instance_id }}
      instance_ip: ${{ steps.deploy_ec2.outputs.instance_ip }}
      security_group_id: ${{ steps.deploy_ec2.outputs.security_group_id }}
      ui_url: ${{ steps.deploy_ec2.outputs.ui_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Verify UI source exists
      run: |
        echo "Verifying UI source directory exists at /axialy-ui-product..."
        if [ ! -d "axialy-ui-product" ]; then
          echo "ERROR: axialy-ui-product directory not found!"
          echo "Available directories in repo root:"
          ls -la
          exit 1
        fi
        echo "✓ UI source directory found"
        echo "Contents of axialy-ui-product:"
        find axialy-ui-product -type f -name "*.php" | head -10

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ github.event.inputs.aws_region }}

    - name: Wait for cleanup completion
      run: |
        echo "Waiting 30 seconds for AWS resource cleanup to propagate..."
        sleep 30

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.6
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: infra/aws_ui
      run: terraform init

    - name: Terraform Plan
      working-directory: infra/aws_ui
      run: |
        terraform plan \
          -var="instance_identifier=${{ env.INSTANCE_IDENTIFIER }}" \
          -var="aws_region=${{ github.event.inputs.aws_region }}" \
          -var="instance_type=${{ github.event.inputs.instance_type }}" \
          -var="domain_name=${{ github.event.inputs.domain_name }}" \
          -var="key_pair_name=${{ secrets.EC2_KEY_PAIR }}" \
          -var="db_host=${{ secrets.DB_HOST }}" \
          -var="db_port=${{ secrets.DB_PORT }}" \
          -var="db_user=${{ secrets.DB_USER }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -var="smtp_host=${{ secrets.SMTP_HOST }}" \
          -var="smtp_port=${{ secrets.SMTP_PORT }}" \
          -var="smtp_user=${{ secrets.SMTP_USER }}" \
          -var="smtp_password=${{ secrets.SMTP_PASSWORD }}" \
          -var="smtp_secure=${{ secrets.SMTP_SECURE }}"

    - name: Import existing resources if they exist
      working-directory: infra/aws_ui
      run: |
        # Create import helper script
        cat > import_existing.sh << 'EOF'
        #!/bin/bash
        set +e  # Don't exit on errors for imports
        
        # Import security group if exists
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=${{ env.INSTANCE_IDENTIFIER }}-sg" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        if [ "$SG_ID" != "None" ] && [ "$SG_ID" != "" ]; then
          echo "Importing security group: $SG_ID"
          terraform import \
            -var="instance_identifier=${{ env.INSTANCE_IDENTIFIER }}" \
            -var="aws_region=${{ github.event.inputs.aws_region }}" \
            -var="instance_type=${{ github.event.inputs.instance_type }}" \
            -var="domain_name=${{ github.event.inputs.domain_name }}" \
            -var="key_pair_name=${{ secrets.EC2_KEY_PAIR }}" \
            -var="db_host=${{ secrets.DB_HOST }}" \
            -var="db_port=${{ secrets.DB_PORT }}" \
            -var="db_user=${{ secrets.DB_USER }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="smtp_host=${{ secrets.SMTP_HOST }}" \
            -var="smtp_port=${{ secrets.SMTP_PORT }}" \
            -var="smtp_user=${{ secrets.SMTP_USER }}" \
            -var="smtp_password=${{ secrets.SMTP_PASSWORD }}" \
            -var="smtp_secure=${{ secrets.SMTP_SECURE }}" \
            aws_security_group.axialy_ui "$SG_ID"
        fi
        
        # Import log group if exists
        LOG_GROUP="/aws/ec2/${{ env.INSTANCE_IDENTIFIER }}"
        if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text 2>/dev/null | grep -q "$LOG_GROUP"; then
          echo "Importing log group: $LOG_GROUP"
          terraform import \
            -var="instance_identifier=${{ env.INSTANCE_IDENTIFIER }}" \
            -var="aws_region=${{ github.event.inputs.aws_region }}" \
            -var="instance_type=${{ github.event.inputs.instance_type }}" \
            -var="domain_name=${{ github.event.inputs.domain_name }}" \
            -var="key_pair_name=${{ secrets.EC2_KEY_PAIR }}" \
            -var="db_host=${{ secrets.DB_HOST }}" \
            -var="db_port=${{ secrets.DB_PORT }}" \
            -var="db_user=${{ secrets.DB_USER }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="smtp_host=${{ secrets.SMTP_HOST }}" \
            -var="smtp_port=${{ secrets.SMTP_PORT }}" \
            -var="smtp_user=${{ secrets.SMTP_USER }}" \
            -var="smtp_password=${{ secrets.SMTP_PASSWORD }}" \
            -var="smtp_secure=${{ secrets.SMTP_SECURE }}" \
            aws_cloudwatch_log_group.axialy_ui "$LOG_GROUP"
        fi
        
        # Import EC2 instance if exists
        EXISTING_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.INSTANCE_IDENTIFIER }}" "Name=instance-state-name,Values=running,pending,stopping,stopped" \
          --query 'Reservations[].Instances[].InstanceId' --output text)
        if [ -n "$EXISTING_INSTANCES" ]; then
          for instance_id in $EXISTING_INSTANCES; do
            echo "Importing EC2 instance: $instance_id"
            terraform import \
              -var="instance_identifier=${{ env.INSTANCE_IDENTIFIER }}" \
              -var="aws_region=${{ github.event.inputs.aws_region }}" \
              -var="instance_type=${{ github.event.inputs.instance_type }}" \
              -var="domain_name=${{ github.event.inputs.domain_name }}" \
              -var="key_pair_name=${{ secrets.EC2_KEY_PAIR }}" \
              -var="db_host=${{ secrets.DB_HOST }}" \
              -var="db_port=${{ secrets.DB_PORT }}" \
              -var="db_user=${{ secrets.DB_USER }}" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -var="smtp_host=${{ secrets.SMTP_HOST }}" \
              -var="smtp_port=${{ secrets.SMTP_PORT }}" \
              -var="smtp_user=${{ secrets.SMTP_USER }}" \
              -var="smtp_password=${{ secrets.SMTP_PASSWORD }}" \
              -var="smtp_secure=${{ secrets.SMTP_SECURE }}" \
              aws_instance.axialy_ui "$instance_id"
          done
        fi
        
        set -e  # Re-enable exit on errors
        EOF
        
        chmod +x import_existing.sh
        ./import_existing.sh || echo "Import completed with some resources already managed"

    - name: Terraform Apply
      id: deploy_ec2
      working-directory: infra/aws_ui
      run: |
        terraform apply -auto-approve \
          -var="instance_identifier=${{ env.INSTANCE_IDENTIFIER }}" \
          -var="aws_region=${{ github.event.inputs.aws_region }}" \
          -var="instance_type=${{ github.event.inputs.instance_type }}" \
          -var="domain_name=${{ github.event.inputs.domain_name }}" \
          -var="key_pair_name=${{ secrets.EC2_KEY_PAIR }}" \
          -var="db_host=${{ secrets.DB_HOST }}" \
          -var="db_port=${{ secrets.DB_PORT }}" \
          -var="db_user=${{ secrets.DB_USER }}" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -var="smtp_host=${{ secrets.SMTP_HOST }}" \
          -var="smtp_port=${{ secrets.SMTP_PORT }}" \
          -var="smtp_user=${{ secrets.SMTP_USER }}" \
          -var="smtp_password=${{ secrets.SMTP_PASSWORD }}" \
          -var="smtp_secure=${{ secrets.SMTP_SECURE }}"

        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "instance_ip=$(terraform output -raw instance_ip)" >> $GITHUB_OUTPUT
        echo "security_group_id=$(terraform output -raw security_group_id)" >> $GITHUB_OUTPUT
        echo "ui_url=$(terraform output -raw ui_url)" >> $GITHUB_OUTPUT

    - name: Wait for instance to be ready
      run: |
        echo "Waiting for EC2 instance to be running..."
        aws ec2 wait instance-running --instance-ids ${{ steps.deploy_ec2.outputs.instance_id }}
        echo "EC2 instance is running"

    - name: Setup SSH with passphrase-protected key
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Setting up SSH with passphrase-protected key..."
        
        # Create SSH directory
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Write the private key to file
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key.pem
        chmod 600 ~/.ssh/ec2_key.pem
        
        # Install expect for handling passphrases
        sudo apt-get update -qq
        sudo apt-get install -y expect
        
        # Create improved expect script for SSH commands
        cat > ~/.ssh/ssh_expect.exp << 'EOF'
        #!/usr/bin/expect -f
        set timeout 120
        set host [lindex $argv 0]
        set command [lindex $argv 1]
        set passphrase $env(EC2_SSH_PASSPHRASE)
        
        log_user 1
        
        spawn ssh -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  -o ConnectTimeout=30 \
                  -o ServerAliveInterval=10 \
                  -o ServerAliveCountMax=3 \
                  -o BatchMode=no \
                  -i ~/.ssh/ec2_key.pem \
                  ec2-user@$host \
                  $command
        
        expect {
            "Enter passphrase for key" {
                send "$passphrase\r"
                exp_continue
            }
            "Are you sure you want to continue connecting" {
                send "yes\r"
                exp_continue
            }
            "Permission denied" {
                puts stderr "SSH authentication failed"
                exit 1
            }
            "Connection refused" {
                puts stderr "SSH connection refused"
                exit 2
            }
            "No route to host" {
                puts stderr "No route to host"
                exit 3
            }
            -re ".*\\$ " {
                # Command prompt appeared - command completed
            }
            timeout {
                puts stderr "SSH timeout after 120 seconds"
                exit 4
            }
            eof {
                # Connection closed - command completed
            }
        }
        
        catch wait result
        set exit_code [lindex $result 3]
        exit $exit_code
        EOF
        chmod +x ~/.ssh/ssh_expect.exp
        
        # Create improved expect script for SCP
        cat > ~/.ssh/scp_expect.exp << 'EOF'
        #!/usr/bin/expect -f
        set timeout 600
        set source [lindex $argv 0]
        set dest [lindex $argv 1]
        set passphrase $env(EC2_SSH_PASSPHRASE)
        
        log_user 1
        
        spawn scp -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  -o ConnectTimeout=30 \
                  -r \
                  -i ~/.ssh/ec2_key.pem \
                  $source $dest
        
        expect {
            "Enter passphrase for key" {
                send "$passphrase\r"
                exp_continue
            }
            "Are you sure you want to continue connecting" {
                send "yes\r"
                exp_continue
            }
            "Permission denied" {
                puts stderr "SCP authentication failed"
                exit 1
            }
            "Connection refused" {
                puts stderr "SCP connection refused"
                exit 2
            }
            "100%" {
                exp_continue
            }
            timeout {
                puts stderr "SCP timeout after 600 seconds"
                exit 4
            }
            eof {
                # Transfer completed
            }
        }
        
        catch wait result
        set exit_code [lindex $result 3]
        exit $exit_code
        EOF
        chmod +x ~/.ssh/scp_expect.exp
        
        echo "SSH setup completed"

    - name: Wait for SSH to be available
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Waiting for SSH to be available..."
        
        for i in {1..20}; do
          echo "Testing SSH connection (attempt $i/20)..."
          
          if ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "echo 'SSH ready'" 2>/dev/null | grep -q "SSH ready"; then
            echo "✓ SSH is ready and responding"
            break
          fi
          
          if [ $i -eq 20 ]; then
            echo "❌ SSH failed to become available after 20 attempts"
            echo "Attempting direct connection test..."
            ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "echo 'SSH test'" || true
            exit 1
          fi
          
          echo "SSH not ready, waiting 30 seconds..."
          sleep 30
        done

########

    - name: Prepare UI application files
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Preparing UI application files for deployment..."
        
        # Verify axialy-ui-product directory exists (as required)
        if [ ! -d "axialy-ui-product" ]; then
          echo "ERROR: axialy-ui-product directory not found at repo root!"
          echo "Available directories:"
          ls -la
          exit 1
        fi
        
        echo "✓ Found axialy-ui-product source directory"
        echo "Contents:"
        ls -la axialy-ui-product/ | head -10
        
        # Create the .env file for UI application
        cat > axialy-ui-product/.env << EOF
        # Database configuration for UI
        UI_DB_HOST=${{ secrets.DB_HOST }}
        UI_DB_PORT=${{ secrets.DB_PORT }}
        UI_DB_USER=${{ secrets.DB_USER }}
        UI_DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        UI_DB_NAME=axialy_ui
        
        # Legacy database config (for backward compatibility)
        DB_HOST=${{ secrets.DB_HOST }}
        DB_PORT=${{ secrets.DB_PORT }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        DB_NAME=axialy_ui
        
        # SMTP configuration
        SMTP_HOST=${{ secrets.SMTP_HOST }}
        SMTP_PORT=${{ secrets.SMTP_PORT }}
        SMTP_USER=${{ secrets.SMTP_USER }}
        SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
        SMTP_SECURE=${{ secrets.SMTP_SECURE }}
        
        # Application URLs
        APP_BASE_URL=http://${{ steps.deploy_ec2.outputs.instance_ip }}
        API_BASE_URL=
        INTERNAL_API_KEY=
        
        # Version
        APP_VERSION=1.0.0
        EOF
        
        echo "✓ UI application files prepared with correct .env"

    - name: Prepare UI application files
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Preparing UI application files for deployment..."
        
        # Verify axialy-ui-product directory exists (as required)
        if [ ! -d "axialy-ui-product" ]; then
          echo "ERROR: axialy-ui-product directory not found at repo root!"
          echo "Available directories:"
          ls -la
          exit 1
        fi
        
        echo "✓ Found axialy-ui-product source directory"
        echo "Contents:"
        ls -la axialy-ui-product/ | head -10
        
        # Create the .env file for UI application
        cat > axialy-ui-product/.env << EOF
        # Database configuration for UI
        UI_DB_HOST=${{ secrets.DB_HOST }}
        UI_DB_PORT=${{ secrets.DB_PORT }}
        UI_DB_USER=${{ secrets.DB_USER }}
        UI_DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        UI_DB_NAME=axialy_ui
        
        # Legacy database config (for backward compatibility)
        DB_HOST=${{ secrets.DB_HOST }}
        DB_PORT=${{ secrets.DB_PORT }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        DB_NAME=axialy_ui
        
        # SMTP configuration
        SMTP_HOST=${{ secrets.SMTP_HOST }}
        SMTP_PORT=${{ secrets.SMTP_PORT }}
        SMTP_USER=${{ secrets.SMTP_USER }}
        SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
        SMTP_SECURE=${{ secrets.SMTP_SECURE }}
        
        # Application URLs
        APP_BASE_URL=http://${{ steps.deploy_ec2.outputs.instance_ip }}
        API_BASE_URL=
        INTERNAL_API_KEY=
        
        # Stripe configuration
        STRIPE_API_KEY=${{ secrets.STRIPE_API_KEY }}
        STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }}
        STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}
        
        # Version
        APP_VERSION=1.0.0
        EOF
        
        echo "✓ UI application files prepared with correct .env"

    - name: Copy UI application files to EC2
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Copying UI application files to EC2..."
        ~/.ssh/scp_expect.exp axialy-ui-product/ "ec2-user@${{ steps.deploy_ec2.outputs.instance_ip }}:~/"
        echo "✓ File transfer completed"

    - name: Install system packages on EC2
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Installing system packages..."
        
        # Update system
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo dnf update -y"
        
        # Install web server packages (matching admin exactly)
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo dnf install -y httpd php php-cli php-fpm php-mysqlnd php-zip php-xml php-mbstring php-curl php-gd php-opcache mariadb105 unzip wget --skip-broken"
        
        echo "✓ System packages installed"

    - name: Configure web server on EC2
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Configuring web server..."
        
        # Create Apache configuration file (matching admin pattern)
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cat > /tmp/axialy-ui.conf << 'APACHE_EOF'
        <VirtualHost *:80>
            DocumentRoot /var/www/html/axialy-ui
            ServerName ui.axialy.com
            DirectoryIndex login.php index.php
            
            <Directory /var/www/html/axialy-ui>
                Options -Indexes +FollowSymLinks
                AllowOverride All
                Require all granted
                
                # Security headers
                Header always set X-Content-Type-Options nosniff
                Header always set X-Frame-Options DENY
                Header always set X-XSS-Protection \"1; mode=block\"
                Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains\"
                Header always set Referrer-Policy \"strict-origin-when-cross-origin\"
            </Directory>
            
            # Hide sensitive files
            <FilesMatch \"\.(env|log|ini)$\">
                Require all denied
            </FilesMatch>
            
            # PHP handling
            <FilesMatch \.php$>
                SetHandler \"proxy:unix:/run/php-fpm/www.sock|fcgi://localhost\"
            </FilesMatch>
            
            # Logging
            ErrorLog /var/log/httpd/axialy-ui-error.log
            CustomLog /var/log/httpd/axialy-ui-access.log combined
        </VirtualHost>
        APACHE_EOF"
        
        # Move configuration to proper location
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo mv /tmp/axialy-ui.conf /etc/httpd/conf.d/"
        
        # Enable mod_headers for security headers
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "echo 'LoadModule headers_module modules/mod_headers.so' | sudo tee -a /etc/httpd/conf/httpd.conf"
        
        echo "✓ Web server configured"

    - name: Deploy UI application files on EC2
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Deploying UI application files..."
        
        # Create web directory and deploy files (matching admin exactly)
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo mkdir -p /var/www/html/axialy-ui"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo cp -r ~/axialy-ui-product/. /var/www/html/axialy-ui/"
        
        # Set permissions (matching admin exactly)
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo chown -R apache:apache /var/www/html/axialy-ui"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo chmod -R 755 /var/www/html/axialy-ui"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo chmod 644 /var/www/html/axialy-ui/.env"
        
        # Create log directories
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo mkdir -p /var/log/axialy-ui"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo chown apache:apache /var/log/axialy-ui"
        
        echo "✓ UI application files deployed"

    - name: Install Composer and PHP dependencies on EC2
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Installing Composer and PHP dependencies..."
        
        # Install Composer globally
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cd ~ && curl -sS https://getcomposer.org/installer | sudo php"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo mv ~/composer.phar /usr/local/bin/composer"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo chmod +x /usr/local/bin/composer"
        
        # Verify Composer installation
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "composer --version"
        
        # Remove outdated lock file and install fresh dependencies
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cd /var/www/html/axialy-ui && sudo rm -f composer.lock"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cd /var/www/html/axialy-ui && sudo COMPOSER_ALLOW_SUPERUSER=1 composer install --no-dev --optimize-autoloader"
        
        # Fix permissions for vendor directory
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo chown -R apache:apache /var/www/html/axialy-ui/vendor/"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo chmod -R 755 /var/www/html/axialy-ui/vendor/"
        
        # Verify PHPMailer installation
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cd /var/www/html/axialy-ui && php -r \"require 'vendor/autoload.php'; echo class_exists('PHPMailer\\\\PHPMailer\\\\PHPMailer') ? 'PHPMailer: OK' : 'PHPMailer: MISSING'; echo PHP_EOL;\""
        
        # Verify Stripe SDK installation
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cd /var/www/html/axialy-ui && php -r \"require 'vendor/autoload.php'; echo class_exists('Stripe\\\\Stripe') ? 'Stripe SDK: OK' : 'Stripe SDK: MISSING'; echo PHP_EOL;\""
        
        echo "✓ Composer and PHP dependencies installed successfully"

    - name: Start services and test on EC2
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Starting services..."
        
        # Start and enable services (matching admin exactly)
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl start httpd"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl enable httpd"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl start php-fpm"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl enable php-fpm"
        
        # Restart services to ensure configuration is loaded
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl restart httpd"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl restart php-fpm"
        
        echo "✓ Services started successfully"

    - name: Setup SSL/HTTPS with Let's Encrypt
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
        NAMESILO_API_KEY: ${{ secrets.NAMESILO_API_KEY }}
      run: |
        echo "Setting up SSL/HTTPS for ui.axialy.ai..."
        
        # First, create DNS record for ui.axialy.ai
        echo "Creating DNS A record for ui.axialy.ai..."
        
        # Create DNS A record using NameSilo API
        DNS_RESPONSE=$(curl -s "https://www.namesilo.com/api/dnsAddRecord?version=1&type=xml&key=$NAMESILO_API_KEY&domain=axialy.ai&rrtype=A&rrhost=ui&rrvalue=${{ steps.deploy_ec2.outputs.instance_ip }}&rrttl=3600")
        echo "DNS API Response: $DNS_RESPONSE"
        
        if echo "$DNS_RESPONSE" | grep -q "<code>300</code>"; then
          echo "✓ DNS A record created successfully"
        elif echo "$DNS_RESPONSE" | grep -q "<code>280</code>"; then
          echo "✓ DNS A record already exists"
        else
          echo "⚠ DNS record creation may have failed, but continuing..."
        fi
        
        # Wait for DNS propagation
        echo "Waiting for DNS propagation..."
        for i in {1..10}; do
          if nslookup ui.axialy.ai 8.8.8.8 | grep -q "${{ steps.deploy_ec2.outputs.instance_ip }}"; then
            echo "✓ DNS propagation complete"
            break
          fi
          echo "Waiting for DNS... attempt $i/10"
          sleep 30
        done
        
        # Install Certbot for Let's Encrypt SSL certificates
        echo "Installing Certbot..."
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo dnf install -y certbot python3-certbot-apache"
        
        # Stop Apache temporarily for certificate generation
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl stop httpd"
        
        # Create SSL certificate using Certbot standalone mode
        echo "Generating SSL certificate..."
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo certbot certonly --standalone --non-interactive --agree-tos --email support@axiaba.com -d ui.axialy.ai"
        
        # Configure Apache for HTTPS
        echo "Configuring Apache for HTTPS..."
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cat > /tmp/axialy-ui-ssl.conf << 'SSL_CONF_EOF'
        # HTTP to HTTPS redirect
        <VirtualHost *:80>
            ServerName ui.axialy.ai
            DocumentRoot /var/www/html/axialy-ui
            Redirect permanent / https://ui.axialy.ai/
        </VirtualHost>
        
        # HTTPS configuration
        <VirtualHost *:443>
            ServerName ui.axialy.ai
            DocumentRoot /var/www/html/axialy-ui
            DirectoryIndex login.php index.php
            
            # SSL Configuration
            SSLEngine on
            SSLCertificateFile /etc/letsencrypt/live/ui.axialy.ai/fullchain.pem
            SSLCertificateKeyFile /etc/letsencrypt/live/ui.axialy.ai/privkey.pem
            
            # Modern SSL Configuration
            SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1
            SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
            SSLHonorCipherOrder off
            SSLSessionTickets off
            
            <Directory /var/www/html/axialy-ui>
                Options -Indexes +FollowSymLinks
                AllowOverride All
                Require all granted
                
                # Security headers
                Header always set X-Content-Type-Options nosniff
                Header always set X-Frame-Options DENY
                Header always set X-XSS-Protection \"1; mode=block\"
                Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"
                Header always set Referrer-Policy \"strict-origin-when-cross-origin\"
            </Directory>
            
            # Hide sensitive files
            <FilesMatch \"\.(env|log|ini)$\">
                Require all denied
            </FilesMatch>
            
            # PHP handling
            <FilesMatch \.php$>
                SetHandler \"proxy:unix:/run/php-fpm/www.sock|fcgi://localhost\"
            </FilesMatch>
            
            # Logging
            ErrorLog /var/log/httpd/axialy-ui-ssl-error.log
            CustomLog /var/log/httpd/axialy-ui-ssl-access.log combined
        </VirtualHost>
        SSL_CONF_EOF"
        
        # Install the SSL configuration
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo mv /tmp/axialy-ui-ssl.conf /etc/httpd/conf.d/"
        
        # Remove old non-SSL configuration
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo rm -f /etc/httpd/conf.d/axialy-ui.conf"
        
        # Enable SSL module
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo dnf install -y mod_ssl"
        
        # Update .env file with HTTPS URL
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo sed -i 's|APP_BASE_URL=http://.*|APP_BASE_URL=https://ui.axialy.ai|' /var/www/html/axialy-ui/.env"
        
        # Restart Apache with SSL
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl start httpd"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl reload httpd"
        
        # Setup automatic certificate renewal
        echo "Setting up automatic SSL certificate renewal..."
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl enable certbot-renew.timer"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl start certbot-renew.timer"
        
        # Test SSL configuration
        echo "Testing SSL configuration..."
        sleep 10
        
        if curl -s -I https://ui.axialy.ai | grep -q "HTTP/2 200\|HTTP/1.1 200"; then
          echo "✓ HTTPS is working correctly!"
        else
          echo "⚠ HTTPS may need a few more minutes to be fully active"
        fi
        
        echo "✓ SSL/HTTPS setup completed successfully!"
        echo "Your UI is now available at: https://ui.axialy.ai"

    - name: Test database connection and dependencies on EC2
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Testing database connection and PHP dependencies..."
        
        # Test database connection with the UI's expected configuration
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "php -r \"
        require_once '/var/www/html/axialy-ui/includes/db_connection.php';
        try {
            echo 'Database connection successful!' . PHP_EOL;
            echo 'Connected to: ' . getenv('UI_DB_HOST') . ':' . getenv('UI_DB_PORT') . PHP_EOL;
            echo 'Database: ' . getenv('UI_DB_NAME') . PHP_EOL;
        } catch (Exception \\\$e) {
            echo 'Database connection failed: ' . \\\$e->getMessage() . PHP_EOL;
            exit(1);
        }
        \""
        
        # Test PHPMailer availability
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cd /var/www/html/axialy-ui && php -r \"
        require_once 'vendor/autoload.php';
        use PHPMailer\PHPMailer\PHPMailer;
        try {
            \\\$mail = new PHPMailer(true);
            echo 'PHPMailer loaded successfully!' . PHP_EOL;
            echo 'PHPMailer version: ' . PHPMailer::VERSION . PHP_EOL;
        } catch (Exception \\\$e) {
            echo 'PHPMailer test failed: ' . \\\$e->getMessage() . PHP_EOL;
            exit(1);
        }
        \""
        
        # Test email configuration (without actually sending)
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "cd /var/www/html/axialy-ui && php -r \"
        require_once 'includes/Mailer.php';
        use AxiaBA\Mailer;
        try {
            \\\$mail = Mailer::make();
            echo 'SMTP configuration loaded successfully!' . PHP_EOL;
            echo 'SMTP Host: ' . getenv('SMTP_HOST') . PHP_EOL;
            echo 'SMTP Port: ' . getenv('SMTP_PORT') . PHP_EOL;
        } catch (Exception \\\$e) {
            echo 'SMTP configuration test failed: ' . \\\$e->getMessage() . PHP_EOL;
            exit(1);
        }
        \""
        
        echo "✓ Database connection and dependency tests completed successfully"

    - name: Verify service status on EC2
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Verifying service status..."
        
        # Check service status
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl status httpd --no-pager"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo systemctl status php-fpm --no-pager"
        
        # Check if files are in place (like admin does)
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "ls -la /var/www/html/axialy-ui/ | head -10"
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "ls -la /var/www/html/axialy-ui/includes/ | head -5"
        
        echo "✓ Service verification completed"
        echo "✓ Deployment completed successfully!"

    - name: Test application deployment
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        UI_URL: ${{ steps.deploy_ec2.outputs.ui_url }}
      run: |
        echo "Testing UI application deployment..."
        
        # Wait a moment for services to fully start
        sleep 15
        
        # Test HTTP response to login page (matching admin pattern)
        echo "Testing HTTP response to login page..."
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$UI_URL/login.php" || echo "000")
        
        if [ "$HTTP_STATUS" = "200" ]; then
          echo "✓ UI login page is responding correctly (HTTP $HTTP_STATUS)"
        else
          echo "⚠ UI login page response status: HTTP $HTTP_STATUS"
          echo "Checking error logs..."
          ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo tail -20 /var/log/httpd/axialy-ui-error.log" || true
          ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo tail -10 /var/log/php_errors.log" || true
        fi
        
        # Test root URL
        echo "Testing root URL..."
        ROOT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$UI_URL" || echo "000")
        echo "Root URL status: HTTP $ROOT_STATUS"
        
        # Test if login page loads correctly (matching admin check)
        echo "Testing application content..."
        if curl -s "$UI_URL/login.php" | grep -q "AxiaBA Login\|login-container"; then
          echo "✓ UI login page is loading correctly"
        else
          echo "⚠ UI login page content issue detected"
        fi

    - name: Debug and troubleshoot issues
      if: failure()
      env:
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        EC2_SSH_PASSPHRASE: ${{ secrets.EC2_SSH_PASSPHRASE }}
      run: |
        echo "Deployment failed - collecting debug information..."
        
        # Check Apache error logs
        echo "=== Apache Error Log ==="
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo tail -50 /var/log/httpd/error_log" || true
        
        echo "=== UI Error Log ==="
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo tail -50 /var/log/httpd/axialy-ui-error.log" || true
        
        # Check PHP error logs
        echo "=== PHP Error Log ==="
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo tail -50 /var/log/php_errors.log" || true
        
        # Check file permissions
        echo "=== File Permissions ==="
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "ls -la /var/www/html/axialy-ui/" || true
        
        # Check if PHP files are accessible
        echo "=== PHP File Test ==="
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "php -l /var/www/html/axialy-ui/login.php" || true
        
        # Check Apache configuration
        echo "=== Apache Config Test ==="
        ~/.ssh/ssh_expect.exp "${{ steps.deploy_ec2.outputs.instance_ip }}" "sudo httpd -t" || true

    - name: Save deployment info as repository secrets
      env:
        GH_TOKEN: ${{ secrets.GH_PAT }}
        INSTANCE_ID: ${{ steps.deploy_ec2.outputs.instance_id }}
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        UI_URL: ${{ steps.deploy_ec2.outputs.ui_url }}
      run: |
        if [ -z "$GH_TOKEN" ]; then
          echo "::warning::GH_PAT secret not set. Cannot update repository secrets automatically."
          echo "Please manually add these deployment details as repository secrets:"
          echo "- UI_INSTANCE_ID: $INSTANCE_ID"
          echo "- UI_INSTANCE_IP: $INSTANCE_IP"
          echo "- UI_URL: $UI_URL"
          exit 0
        fi

        gh secret set UI_INSTANCE_ID --body "$INSTANCE_ID"
        gh secret set UI_INSTANCE_IP --body "$INSTANCE_IP"
        gh secret set UI_URL --body "$UI_URL"
        echo "✓ Deployment info saved as repository secrets"

    - name: Display deployment summary
      env:
        INSTANCE_ID: ${{ steps.deploy_ec2.outputs.instance_id }}
        INSTANCE_IP: ${{ steps.deploy_ec2.outputs.instance_ip }}
        UI_URL: ${{ steps.deploy_ec2.outputs.ui_url }}
      run: |
        echo "=================================================="
        echo "AWS Axialy UI deployed successfully!"
        echo "=================================================="
        echo "Instance ID: $INSTANCE_ID"
        echo "Public IP: $INSTANCE_IP"
        echo "Region: ${{ github.event.inputs.aws_region }}"
        echo "Instance Type: ${{ github.event.inputs.instance_type }}"
        echo "=================================================="
        echo ""
        echo "Access URLs:"
        echo "- UI Login Page: $UI_URL/login.php"
        echo "- UI Application: $UI_URL (redirects to login)"
        echo ""
        echo "SSH Access:"
        echo "- Command: ssh -i ~/.ssh/your_key.pem ec2-user@$INSTANCE_IP"
        echo "- Key uses passphrase: YES"
        echo ""
        echo "Database Connection:"
        echo "- Connected to: ${{ secrets.DB_HOST }}"
        echo "- Database: axialy_ui"
        echo ""
        echo "Email Configuration:"
        echo "- SMTP Host: ${{ secrets.SMTP_HOST }}"
        echo "- SMTP Port: ${{ secrets.SMTP_PORT }}"
        echo ""
        echo "Next Steps:"
        echo "1. Access the UI login page: $UI_URL/login.php"
        echo "2. Create a new account using the email verification flow"
        echo "3. Test user registration and email functionality"
        echo "4. Configure DNS if using custom domain"
        echo "5. Deploy Axialy API (Install 4) for full functionality"
        echo ""
        echo "Security Notes:"
        echo "- SSL/HTTPS should be configured for production"
        echo "- Monitor application logs in /var/log/httpd/"
        echo "- Email verification tokens should be tested"
        echo "- Regular security updates recommended"
        echo ""
        echo "Troubleshooting:"
        echo "- Check logs: ssh to server and run 'sudo tail -f /var/log/httpd/axialy-ui-error.log'"
        echo "- Check PHP errors: 'sudo tail -f /var/log/php_errors.log'"
        echo "- Verify database connection from server"
        echo "=================================================="

  cleanup:
    runs-on: ubuntu-latest
    name: Cleanup Temporary Resources
    needs: deploy
    if: always()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ github.event.inputs.aws_region }}

    - name: Cleanup temporary resources
      run: |
        echo "Performing cleanup of temporary resources..."
        
        # Note: In this deployment, we keep the main resources (EC2, Security Groups)
        # but clean up any temporary files or failed deployments
        
        # This is a placeholder for any cleanup logic
        # Similar to admin deployment, the EC2 instance IS the final product
        
        echo "✓ Cleanup completed (no temporary resources to clean)"

    - name: Final status report
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "🎉 Axialy UI deployment completed successfully!"
          echo "UI application '${{ env.INSTANCE_IDENTIFIER }}' is ready for use."
          echo "Access the login page at: ${{ needs.deploy.outputs.ui_url }}/login.php"
        else
          echo "⚠️  Deployment encountered issues. Check the deploy job logs."
          echo "Common troubleshooting steps:"
          echo "1. Check if axialy-ui-product directory exists in repo root"
          echo "2. Verify database credentials are correct"
          echo "3. Check EC2 instance logs for PHP/Apache errors"
        fi
